<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pomodoro Plant Timer</title>
  <style>
    html {
      font-size: 14px;
    }

    /* Opgelost: @@media om Razor parsing fout te voorkomen */
    @@media (min-width: 768px) {
      html {
        font-size: 16px;
      }
    }

    body {
      margin: 0;
      background-color: #faf5ea;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      color: #1f2933;
    }

    .plant-page {
      min-height: 100vh;
      padding: 24px 16px 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .plant-header {
      max-width: 640px;
      width: 100%;
      text-align: center;
      margin-bottom: 24px;
    }

    .plant-title {
      margin: 0 0 8px;
      font-size: 1.75rem;
      font-weight: 700;
      color: #215f3a;
    }

    .plant-subtitle {
      margin: 0;
      font-size: 0.95rem;
      color: #6b7280;
    }

    .plant-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 24px;
      max-width: 640px;
      width: 100%;
    }

    .plant-card {
      width: 100%;
      background: #fdf8ee;
      border-radius: 24px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.06);
      padding: 24px 16px 28px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    /* Responsiever: geen harde hoogte, gebruikt aspect ratio */
    .plant-circle-wrapper {
      position: relative;
      width: min(100%, 380px);
      aspect-ratio: 19 / 17;
    }

    .progress-ring {
      position: absolute;
      inset: 0;
      transform: rotate(-90deg);
      z-index: 2;
      pointer-events: none;
    }

    .progress-ring__track {
      fill: none;
      stroke: #e7eadb;
      stroke-width: 7;
    }

    .progress-ring__circle {
      fill: none;
      stroke: #215f3a;
      stroke-width: 7;
      stroke-linecap: round;
      transition: stroke-dashoffset 0.3s ease-out;
    }

    #plantCanvas {
      position: absolute;
      inset: 0;
      z-index: 1;
    }

    .plant-timer {
      text-align: center;
    }

    .plant-time {
      font-size: 3.4rem;
      font-weight: 700;
      color: #25523b;
      letter-spacing: 0.06em;
    }

    .plant-status {
      margin: 4px 0 0;
      font-size: 0.9rem;
      color: #647b6a;
    }

    .mode-switch {
      display: flex;
      gap: 8px;
      margin-top: 4px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .mode-btn {
      padding: 6px 16px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      font-size: 0.8rem;
      cursor: pointer;
      color: #374151;
      transition: background-color 0.15s, color 0.15s, border-color 0.15s, box-shadow 0.15s, transform 0.08s;
    }

    .mode-btn:hover {
      background: #eff6ff;
      border-color: #93c5fd;
    }

    .mode-btn--active {
      background: #215f3a;
      color: #f9fafb;
      border-color: #215f3a;
      box-shadow: 0 8px 18px rgba(24, 94, 52, 0.35);
      transform: translateY(-1px);
    }

    .plant-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      margin-top: 4px;
    }

    .plant-buttons-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .primary-btn {
      padding: 12px 28px;
      border-radius: 999px;
      border: none;
      font-size: 0.95rem;
      font-weight: 600;
      background-color: #215f3a;
      color: white;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.08s ease-out, box-shadow 0.2s;
      box-shadow: 0 10px 24px rgba(24, 94, 52, 0.35);
    }

    .primary-btn:hover {
      background-color: #2a7449;
      transform: translateY(-1px);
    }

    .primary-btn:active {
      transform: translateY(0);
      box-shadow: 0 6px 14px rgba(24, 94, 52, 0.3);
    }

    .primary-btn:disabled {
      opacity: 0.6;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    .ghost-btn {
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      font-size: 0.85rem;
      background-color: white;
      color: #4b5563;
      cursor: pointer;
      transition: background-color 0.15s, border-color 0.15s;
    }

    .ghost-btn:hover {
      background-color: #f3f4f6;
      border-color: #9ca3af;
    }

    .helper-text {
      font-size: 0.8rem;
      color: #9ca3af;
      text-align: center;
    }

    /* Betere focus styles voor keyboard-navigatie */
    button:focus-visible {
      outline: 3px solid #215f3a;
      outline-offset: 2px;
    }

    /* --- Media Query afmetingen --- */
    @@media (max-width: 768px) {
      .plant-card {
        padding: 20px 14px 24px;
      }

      .plant-time {
        font-size: 2.8rem;
      }
    }
  </style>
</head>

<body>
  <div class="plant-page">
    <header class="plant-header">
      <h1 class="plant-title">Pomodoro Plant Timer</h1>
      <p class="plant-subtitle">
        Laat je tomatenplant groeien terwijl jij focust. Elke voltooide pomodoro zorgt voor rijpe tomaten! üçÖ
      </p>
    </header>

    <main class="plant-main" aria-label="Pomodoro plant timer">
      <section class="plant-card" aria-live="polite">
        <div class="plant-circle-wrapper" aria-hidden="true">
          <svg class="progress-ring" viewBox="0 0 220 220">
            <circle class="progress-ring__track" cx="110" cy="110" r="90" />
            <circle class="progress-ring__circle" cx="110" cy="110" r="90" />
          </svg>
          <canvas id="plantCanvas"></canvas>
        </div>

        <section class="plant-timer">
          <div class="plant-time" id="timer" aria-label="Timer">25:00</div>
          <p class="plant-status" id="label">Focus sessie klaar om te starten</p>

          <div class="mode-switch" aria-label="Timer modus">
            <button type="button" class="mode-btn mode-btn--active" data-mode="focus" aria-pressed="true">
              Focus ¬∑ 25 min
            </button>
            <button type="button" class="mode-btn" data-mode="short" aria-pressed="false">
              Korte pauze ¬∑ 5 min
            </button>
            <button type="button" class="mode-btn" data-mode="long" aria-pressed="false">
              Lange pauze ¬∑ 15 min
            </button>
          </div>
        </section>

        <div class="plant-actions">
          <div class="plant-buttons-row">
            <button class="primary-btn" id="start-pause" type="button">
              Start timer
            </button>
            <button class="ghost-btn" id="reset" type="button">
              Reset
            </button>
          </div>
          <p class="helper-text">
            Tip: laat notificaties toe zodat je een melding krijgt als de tijd om is.
          </p>
        </div>
      </section>
    </main>
  </div>

  <script>
    (() => {
      'use strict';

      // ========== UTILITY FUNCTIONS ==========

      // Deterministic pseudo-random number generator
      function pseudoRandom(index) {
        const x = Math.sin(index * 12.9898 + 78.233) * 43758.5453;
        return x - Math.floor(x);
      }

      function lerpColor(c1, c2, t) {
        const r1 = parseInt(c1.substring(1, 3), 16);
        const g1 = parseInt(c1.substring(3, 5), 16);
        const b1 = parseInt(c1.substring(5, 7), 16);
        const r2 = parseInt(c2.substring(1, 3), 16);
        const g2 = parseInt(c2.substring(3, 5), 16);
        const b2 = parseInt(c2.substring(5, 7), 16);
        const r = Math.round(r1 + (r2 - r1) * t);
        const g = Math.round(g1 + (g2 - g1) * t);
        const b = Math.round(b1 + (b2 - b1) * t);
        return `#${((1 << 24) + (r << 16) + (g << 8) + b)
          .toString(16)
          .slice(1)
          .toUpperCase()
          .padStart(6, '0')}`;
      }

      // ========== L-SYSTEM PLANT LOGIC ==========

      const CONFIG = {
        axiom: "X",
        rules: {
          X: "F[+X][-X]FX",
          F: "FF"
        },
        angle: 35,
        iterations: 5,
        baseLength: 18 // controls branch length & tomato size baseline
      };

      let lSystemString = "";
      let canvas = null;
      let ctx = null;
      let plantProgress = 0;
      let plantBounds = { minX: 0, maxX: 0, minY: 0, maxY: 0, width: 0, height: 0 };

      function generateString() {
        let current = CONFIG.axiom;
        for (let i = 0; i < CONFIG.iterations; i++) {
          let next = "";
          for (let char of current) {
            next += CONFIG.rules[char] || char;
          }
          current = next;
        }
        lSystemString = current;
      }

      function measurePlant() {
        let x = 0, y = 0, dir = -Math.PI / 2;
        let stack = [];
        let minX = 0, maxX = 0, minY = 0, maxY = 0;
        const len = CONFIG.baseLength;

        for (let i = 0; i < lSystemString.length; i++) {
          const char = lSystemString[i];
          if (char === 'F') {
            x += Math.cos(dir) * len;
            y += Math.sin(dir) * len;
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          } else if (char === '+') {
            dir += (CONFIG.angle * Math.PI) / 180;
          } else if (char === '-') {
            dir -= (CONFIG.angle * Math.PI) / 180;
          } else if (char === '[') {
            stack.push({ x, y, dir });
          } else if (char === ']') {
            const state = stack.pop();
            x = state.x;
            y = state.y;
            dir = state.dir;
          }
        }

        plantBounds = {
          minX,
          maxX,
          minY,
          maxY,
          width: maxX - minX,
          height: maxY - minY,
          centerX: (minX + maxX) / 2
        };
      }

      function initCanvas() {
        canvas = document.getElementById("plantCanvas");
        if (!canvas) return;
        ctx = canvas.getContext("2d");

        const wrapper = canvas.parentElement;
        const dpr = window.devicePixelRatio || 1;
        const w = wrapper.offsetWidth;
        const h = wrapper.offsetHeight;

        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      // ========== DRAWING FUNCTIONS ==========

      function drawPot(ctx, x, y, size) {
        ctx.save();
        ctx.translate(x, y);

        // Pot Rim
        ctx.fillStyle = "#c06b3e";
        ctx.fillRect(-size / 2 - 4, 0, size + 8, 12);

        // Pot Body
        ctx.beginPath();
        ctx.moveTo(-size / 2, 12);
        ctx.lineTo(size / 2, 12);
        ctx.lineTo(size / 2 - 8, size * 0.8);
        ctx.lineTo(-size / 2 + 8, size * 0.8);
        ctx.closePath();
        ctx.fillStyle = "#d37b4a";
        ctx.fill();

        // Soil
        ctx.beginPath();
        ctx.ellipse(0, 0, size / 2 - 2, 6, 0, 0, Math.PI * 2);
        ctx.fillStyle = "#3e2723";
        ctx.fill();

        ctx.restore();
      }

      // Tomato-style compound leaf: muted, drawing-like
      function drawDetailedLeaf(ctx, size) {
        const leafColor = "#4E7B43";
        const highlightColor = "#83A96A";
        const veinColor = "#3D5F36";

        ctx.save();

        // Central stem
        const stemLen = size * 1.1;
        ctx.strokeStyle = veinColor;
        ctx.lineWidth = Math.max(0.8, size * 0.1);
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -stemLen);
        ctx.stroke();

        // Helper to draw one softer leaflet
        const drawLeaflet = (w, h, offsetY, side) => {
          ctx.save();
          ctx.translate(side * w * 0.5, offsetY);
          ctx.rotate(side * (Math.PI / 12));

          // Base shape
          ctx.fillStyle = leafColor;
          ctx.beginPath();
          ctx.ellipse(0, 0, w, h, 0, 0, Math.PI * 2);
          ctx.fill();

          // Subtle inner highlight
          ctx.fillStyle = highlightColor;
          ctx.globalAlpha = 0.45;
          ctx.beginPath();
          ctx.ellipse(-w * 0.2, -h * 0.15, w * 0.55, h * 0.5, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;

          // A single central vein
          ctx.strokeStyle = veinColor;
          ctx.lineWidth = Math.max(0.5, w * 0.08);
          ctx.beginPath();
          ctx.moveTo(-w * 0.1, -h * 0.5);
          ctx.lineTo(w * 0.15, h * 0.5);
          ctx.stroke();

          ctx.restore();
        };

        // Opposite leaflets along the stem
        const steps = 3;
        for (let i = 0; i < steps; i++) {
          const t = (i + 1) / (steps + 1);
          const y = -stemLen * t;
          const baseW = size * (0.75 - 0.2 * t);
          const baseH = baseW * 0.7;

          drawLeaflet(baseW, baseH, y, 1);
          drawLeaflet(baseW, baseH, y, -1);
        }

        // Terminal leaflet at the top
        const tipW = size * 0.8;
        const tipH = size * 1.1;
        ctx.translate(0, -stemLen);
        ctx.fillStyle = leafColor;
        ctx.beginPath();
        ctx.ellipse(0, 0, tipW, tipH, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = highlightColor;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.ellipse(-tipW * 0.25, -tipH * 0.25, tipW * 0.5, tipH * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.restore();
      }

      function drawRealisticTomato(ctx, size, ripeness) {
        ctx.save();

        // Base color depending on ripeness (muted, less cartoony)
        let baseColor;
        if (ripeness < 0.3) {
          baseColor = lerpColor("#6E8C3A", "#D08C3A", ripeness / 0.3); // greenish to muted orange
        } else {
          baseColor = lerpColor("#D08C3A", "#C53A34", (ripeness - 0.3) / 0.7); // orange to deep red
        }

        // Radial gradient for shading
        const grad = ctx.createRadialGradient(
          -size * 0.3,
          -size * 0.3,
          size * 0.1,
          0,
          0,
          size
        );
        const lightColor = lerpColor(baseColor, "#FFFFFF", 0.25);
        const darkColor = lerpColor(baseColor, "#5A1612", 0.35);
        grad.addColorStop(0, lightColor);
        grad.addColorStop(0.7, baseColor);
        grad.addColorStop(1, darkColor);

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.fill();

        // Very subtle highlight, smaller and softer
        ctx.fillStyle = "rgba(255, 255, 255, 0.18)";
        ctx.beginPath();
        ctx.ellipse(
          -size * 0.28,
          -size * 0.38,
          size * 0.2,
          size * 0.12,
          Math.PI / 5,
          0,
          Math.PI * 2
        );
        ctx.fill();

        // Calyx (muted green, less sharp)
        ctx.fillStyle = "#3C6A2A";
        ctx.beginPath();
        const calyxRadius = size * 0.55;
        const innerRadius = size * 0.18;
        for (let i = 0; i < 5; i++) {
          const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
          ctx.lineTo(Math.cos(angle) * calyxRadius, Math.sin(angle) * calyxRadius);
          ctx.lineTo(
            Math.cos(angle + 0.35) * innerRadius,
            Math.sin(angle + 0.35) * innerRadius
          );
        }
        ctx.closePath();
        ctx.fill();

        ctx.restore();
      }

      function drawPlantLoop() {
        if (!ctx || !canvas) return;

        const w = canvas.width / (window.devicePixelRatio || 1);
        const h = canvas.height / (window.devicePixelRatio || 1);

        ctx.clearRect(0, 0, w, h);

        const cx = w / 2;
        const cy = h / 2;
        const radius = Math.min(w, h) / 2 - 20;

        // Clip Circle Area
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.clip();

        // Draw Pot at the bottom
        const potY = cy + radius * 0.6;
        const potSize = radius * 0.5;
        drawPot(ctx, cx, potY, potSize);

        // --- PLANT SCALING ---
        const availableH = radius * 1.5;
        const availableW = radius * 1.4;

        const pW = plantBounds.width || 1;
        const pH = plantBounds.height || 1;

        const scaleH = availableH / pH;
        const scaleW = availableW / pW;
        // Slightly reduce overall scale so the top of the plant stays away from the ring
        const fitScale = Math.min(scaleH, scaleW) * 0.9;

        ctx.translate(cx, potY);

        // Grow Animation
        const currentScale = fitScale * Math.max(0.05, plantProgress);
        // Make the canopy wider and slightly squashed vertically to feel more tree-like
        const scaleX = currentScale * 1.25;
        const scaleY = currentScale * 0.9;
        ctx.scale(scaleX, scaleY);

        // Center align the plant structure
        ctx.translate(-plantBounds.centerX, -plantBounds.maxY);

        drawLSystemRecursive(ctx);

        ctx.restore();
        requestAnimationFrame(drawPlantLoop);
      }

      function drawLSystemRecursive(ctx) {
        const currentLen = CONFIG.baseLength;
        const stateStack = [];

        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        let currentAngle = -Math.PI / 2;

        for (let i = 0; i < lSystemString.length; i++) {
          const char = lSystemString[i];
          const rnd = pseudoRandom(i);

          if (char === 'F') {
            const relPos = i / lSystemString.length;

            // Tapered stem: slimmer and more natural
            const thickness = Math.max(1.2, 9 * Math.pow(1 - relPos, 0.8));
            ctx.lineWidth = thickness;

            // Muted green palette, slightly lighter towards the top
            const stemColor = lerpColor("#476243", "#76996A", relPos);
            ctx.strokeStyle = stemColor;

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -currentLen);
            ctx.stroke();
            ctx.translate(0, -currentLen);

            // LEAVES ‚Äì one clean cluster every few segments
            if (plantProgress > 0.25 && relPos > 0.2 && i % 5 === 0) {
              ctx.save();
              const side = (rnd > 0.5) ? 1 : -1;
              ctx.rotate(side * (Math.PI / 4));
              const leafSize = currentLen * (0.9 + 0.3 * (1 - relPos)) * plantProgress;
              drawDetailedLeaf(ctx, leafSize);
              ctx.restore();
            }

          } else if (char === 'X') {
            // TOMATOES ‚Äì clearer, bigger fruit, not on every node
            const relPos = i / lSystemString.length;
            if (plantProgress > 0.3 && relPos > 0.25 && relPos < 0.9 && i % 6 === 0) {
              const ripeness = Math.min(1, (plantProgress - 0.3) / 0.7);

              ctx.save();

              // Hang downward from the current branch orientation
              ctx.rotate(-currentAngle + Math.PI);

              ctx.strokeStyle = "#43a047";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(0, 12);
              ctx.stroke();
              ctx.translate(0, 12);

              const baseSize = currentLen * 1.6;
              drawRealisticTomato(ctx, baseSize, ripeness);

              // Small chance of a second tomato right next to it
              if (pseudoRandom(i + 101) > 0.65) {
                ctx.save();
                ctx.translate(baseSize * 0.95, baseSize * 0.15);
                drawRealisticTomato(ctx, baseSize * 0.85, ripeness);
                ctx.restore();
              }

              ctx.restore();
            }
          } else if (char === '+') {
            const angleChange = (CONFIG.angle + rnd * 5) * Math.PI / 180;
            ctx.rotate(angleChange);
            currentAngle += angleChange;
          } else if (char === '-') {
            const angleChange = -(CONFIG.angle + rnd * 5) * Math.PI / 180;
            ctx.rotate(angleChange);
            currentAngle += angleChange;
          } else if (char === '[') {
            stateStack.push({ t: ctx.getTransform(), a: currentAngle });
          } else if (char === ']') {
            const state = stateStack.pop();
            ctx.setTransform(state.t);
            currentAngle = state.a;
          }
        }
      }

      // ========== TIMER LOGIC (Standard) ==========

      const DURATIONS = {
        focus: 0.5 * 60,
        short: 5 * 60,
        long: 15 * 60
      };

      let currentMode = "focus";
      let remainingTime = DURATIONS[currentMode];
      let timerInterval = null;
      let isRunning = false;
      let timerCompleted = false;
      let endTimestamp = null;

      const timerEl = document.getElementById("timer");
      const labelEl = document.getElementById("label");
      const startPauseBtn = document.getElementById("start-pause");
      const resetBtn = document.getElementById("reset");
      const progressCircle = document.querySelector(".progress-ring__circle");
      const modeButtons = document.querySelectorAll(".mode-btn");

      const PROGRESS_RADIUS = 90;
      const PROGRESS_CIRCUMFERENCE = 2 * Math.PI * PROGRESS_RADIUS;

      if (progressCircle) {
        progressCircle.style.strokeDasharray = `${PROGRESS_CIRCUMFERENCE} ${PROGRESS_CIRCUMFERENCE}`;
        progressCircle.style.strokeDashoffset = PROGRESS_CIRCUMFERENCE;
      }

      const completionSound = new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuByPDTgjMGHm7A7+OZSA0PVqzn77BdGAU+ltryxnMoBSh+zPLaizsIGGS57OihUBELTKXh8bllHAU2jdXzzn0vBSV7yvHejj8JE1yw6+6oVBMKRp/g8r5sIQUrgcjw04IzBh5uwO/jmUgND1as5++wXRgFPpba8sZzKAUofczy2os7CBhkuezmn1ASC0yl4fG5ZRwNNo3V8859LwUle8rx3o4/CRNcsOvuqFQTCkaf4PK+bCEFK4HI8NOCMwYebs");

      function formatTime(seconds) {
        const m = String(Math.floor(seconds / 60)).padStart(2, "0");
        const s = String(seconds % 60).padStart(2, "0");
        return `${m}:${s}`;
      }

      function updateProgressAndPlant() {
        const total = DURATIONS[currentMode];
        const elapsed = total - remainingTime;
        const progress = Math.max(0, Math.min(1, elapsed / total));

        if (progressCircle) {
          const offset = PROGRESS_CIRCUMFERENCE * (1 - progress);
          progressCircle.style.strokeDashoffset = offset;
        }
        plantProgress = progress;
      }

      function updateModeButtonAria() {
        modeButtons.forEach(btn => {
          const btnMode = btn.getAttribute("data-mode");
          const isActive = btnMode === currentMode;
          btn.setAttribute("aria-pressed", isActive ? "true" : "false");
          if (isActive) btn.classList.add("mode-btn--active");
          else btn.classList.remove("mode-btn--active");
        });
      }

      function updateDisplay() {
        if (timerEl) timerEl.textContent = formatTime(remainingTime);
        if (labelEl) {
          if (currentMode === "focus") {
            labelEl.textContent = timerCompleted
              ? "Pomodoro voltooid! üçÖ"
              : (isRunning ? "Focus sessie bezig..." : "Focus sessie klaar om te starten");
          } else if (currentMode === "short") {
            labelEl.textContent = timerCompleted ? "Korte pauze voltooid" : "Even kort pauze nemen";
          } else {
            labelEl.textContent = timerCompleted ? "Lange pauze voltooid" : "Neem een langere pauze";
          }
        }
        if (startPauseBtn) {
          startPauseBtn.textContent = isRunning ? "Pauzeer" : "Start timer";
          startPauseBtn.disabled = timerCompleted;
        }
        updateProgressAndPlant();
      }

      function notifyCompletion() {
        completionSound.currentTime = 0;
        completionSound.play().catch(() => { });
        if (typeof window !== "undefined" && "Notification" in window) {
          if (Notification.permission === "granted") {
            new Notification("Pomodoro voltooid! üçÖ");
          } else if (Notification.permission !== 'denied') {
            Notification.requestPermission();
          }
        }
      }

      function tick() {
        if (!isRunning || endTimestamp == null) return;
        const now = Date.now();
        const diffSeconds = Math.max(0, Math.round((endTimestamp - now) / 1000));
        remainingTime = diffSeconds;
        updateDisplay();

        if (remainingTime <= 0) {
          remainingTime = 0;
          stopTimerInternal(false);
          timerCompleted = true;
          updateDisplay();
          notifyCompletion();
        }
      }

      function startTimer() {
        if (isRunning || timerCompleted) return;
        isRunning = true;
        endTimestamp = Date.now() + remainingTime * 1000;
        updateDisplay();
        timerInterval = window.setInterval(tick, 250);
      }

      function stopTimerInternal(updateUI = true) {
        isRunning = false;
        endTimestamp = null;
        if (timerInterval !== null) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        if (updateUI) updateDisplay();
      }

      function stopTimer() { stopTimerInternal(true); }

      function resetTimer() {
        stopTimerInternal(false);
        remainingTime = DURATIONS[currentMode];
        timerCompleted = false;
        plantProgress = 0;
        updateDisplay();
      }

      function setMode(mode) {
        if (!DURATIONS[mode]) return;
        currentMode = mode;
        stopTimerInternal(false);
        remainingTime = DURATIONS[mode];
        timerCompleted = false;
        plantProgress = 0;
        updateModeButtonAria();
        updateDisplay();
      }

      if (startPauseBtn) {
        startPauseBtn.addEventListener("click", () => { isRunning ? stopTimer() : startTimer(); });
      }
      if (resetBtn) {
        resetBtn.addEventListener("click", resetTimer);
      }
      modeButtons.forEach(btn =>
        btn.addEventListener("click", () => {
          const newMode = btn.getAttribute("data-mode");
          if (newMode) setMode(newMode);
        })
      );

      window.addEventListener("load", () => {
        generateString();
        measurePlant();
        initCanvas();
        updateModeButtonAria();
        updateDisplay();
        drawPlantLoop();
      });

      window.addEventListener("resize", () => {
        initCanvas();
      });
    })();
  </script>
</body>

</html>